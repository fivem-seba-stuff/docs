# seba_control

> Integration resource to synchronize credits, balances, and overall FiveM server status with a dedicated backend.

## Description

`seba_control` connects your server to a custom API that manages credits, keeps the backend informed about the server status, and coordinates administrative flows such as scheduled restarts. It includes bypass tooling for development, balance caching, and safeguards against duplicate transactions.

## Key features

- **Backend API integration** — Endpoints for credit operations and server status reporting.
- **Bypass mode** — Mock responses for local development and testing.
- **Balance caching** — Avoids redundant requests and improves response times.
- **Transaction management** — Locks to prevent duplicated operations.
- **txAdmin events** — Handles scheduled restarts and related notifications.
- **Economy validation** — Configurable minimums, maximums, and daily limits.
- **Discord identification** — Automatically resolves player Discord IDs.

## Installation

1. Copy the `seba_control` folder into `resources/`.
2. Add `ensure seba_control` to your `server.cfg`.
3. Configure the ConVars described below.
4. Restart the server.

## Configuration

### Required ConVars (server.cfg)

```cfg
# API Configuration
setr FIVEM_SECRET "your_secret_here"
setr API_BASE_URL "https://your-backend.com/api/fivem"
setr SERVER_ID 1

# Optional API Overrides
setr CREDIT_API_BASE_URL "https://your-backend.com/api/fivem"
setr SERVERS_API_BASE_URL "https://your-backend.com/api/servers"

# Economy Limits
setr SEBA_MIN_AMOUNT 1
setr SEBA_MAX_AMOUNT 1000000
setr SEBA_DAILY_ADD_LIMIT 0

# Bypass Mode (for development/testing)
setr API_BYPASS 0  # Set to 1 to enable mock data mode

# Optional Server Info
setr NEXT_RESTART_INIT ""
setr WIPE_DAYS_INIT 30
```

- **FIVEM_SECRET** must match the secret configured on your backend.
- Keep `API_BASE_URL` as the default unless credit and server endpoints are split.
- Adjust `SEBA_MIN_AMOUNT`, `SEBA_MAX_AMOUNT`, and `SEBA_DAILY_ADD_LIMIT` to match your economy rules.
- Enable `API_BYPASS` in development when you want mock data without live HTTP calls.

## Bypass mode

### Activation

```cfg
setr API_BYPASS 1
```

### Behavior

- All exports return successful mock responses.
- `getBalance()` returns 1000 credits by default.
- No outbound HTTP requests are executed.
- Additional debug messages are printed in the server console.

## Export API

<Tabs items={["Server", "Client"]}>
<Tab>

#### Credit management

##### `spendCredits(playerId, amount, serverName?, description?)`
**Signature:** `exports.seba_control:spendCredits(playerId, amount, serverName, description)`

- **Description:** Deducts credits from a player using their `source` or Discord ID.
- **Parameters:**
  - `playerId` (`number|string`) – Player source or Discord ID.
  - `amount` (`number`) – Credits to deduct.
  - `serverName` (`string`, optional) – Server tag to report to the backend.
  - `description` (`string`, optional) – Free-text description of the transaction.
- **Returns:** `boolean success, string message`.

##### `addCredits(discordId, amount, serverName, description)`
**Signature:** `exports.seba_control:addCredits(discordId, amount, serverName, description)`

- **Description:** Adds credits to a user identified by Discord ID.
- **Parameters:**
  - `discordId` (`string`)
  - `amount` (`number`)
  - `serverName` (`string`)
  - `description` (`string`)
- **Returns:** `boolean success, string message`.

##### `getBalance(discordId)`
**Signature:** `exports.seba_control:getBalance(discordId)`

- **Description:** Fetches the current balance directly from the API.
- **Returns:** `boolean success, number balance`.

##### `getCachedBalance(discordId)`
**Signature:** `exports.seba_control:getCachedBalance(discordId)`

- **Description:** Retrieves the cached balance to avoid frequent API calls.
- **Returns:** `boolean success, number balance`.

#### Server management

##### `updateServerStatus()`
**Signature:** `exports.seba_control:updateServerStatus()`

- **Description:** Synchronizes the current server status with the backend.
- **Returns:** `boolean success, string message`.

##### `refreshServerCard(serverId?, force?)`
**Signature:** `exports.seba_control:refreshServerCard(serverId, force)`

- **Description:** Refreshes the server card shown on external panels.
- **Parameters:**
  - `serverId` (`number`, optional) – Server identifier to refresh.
  - `force` (`boolean`, optional) – Skip cache and force an update.
- **Returns:** `boolean success, string message`.

##### `getServerPlayers(serverId)`
**Signature:** `exports.seba_control:getServerPlayers(serverId)`

- **Description:** Fetches player information for a given server.
- **Returns:** `boolean success, table serverInfo`.

#### Utilities

##### `testAPIConnection()`
**Signature:** `exports.seba_control:testAPIConnection()`

- **Description:** Verifies that the backend is reachable.
- **Returns:** `boolean connected`.

##### `invalidateBalanceCache(discordId)`
**Signature:** `exports.seba_control:invalidateBalanceCache(discordId)`

- **Description:** Removes the cached balance entry so the next call re-fetches data.
- **Returns:** `nil`.

##### `seba_identifier(source, "discord")`
**Signature:** `exports.seba_control:seba_identifier(source, identifierType)`

- **Description:** Helper that resolves identifiers; the most common usage is `"discord"`.
- **Returns:** `string identifier|nil`.

</Tab>
<Tab>

The resource does not expose native client-side exports. To build UI integrations:

- Request data with `TriggerServerEvent` and handle responses with `TriggerClientEvent`.
- Reuse emitted events (see the Events tab) to show notifications or refresh HUD elements.
- If you need the Discord ID on the client, request it from the server via `exports.seba_control:seba_identifier` and forward the result.

</Tab>
</Tabs>

## Events

<Tabs items={["Server", "Client"]}>
<Tab>

##### `seba_control:txadmin:scheduledRestart`
Fires when txAdmin schedules a restart.

- **Payload:** `{ timestamp: number, initiatedBy: string, reason?: string }`
- **Typical usage:** Notify players or persist the restart plan.

```lua
AddEventHandler('seba_control:txadmin:scheduledRestart', function(data)
    print(('Restart scheduled by %s for %s'):format(data.initiatedBy, os.date('%H:%M', data.timestamp)))
end)
```

##### `seba_control:txadmin:restartCancelled`
Emitted when a scheduled restart is cancelled.

- **Payload:** `{ cancelledBy: string }`

##### `seba_control:balance:cacheInvalidated`
Dispatched after `invalidateBalanceCache` is called.

- **Payload:** `{ discordId: string }`
- **Use case:** Refresh HUDs or immediately re-query the API.

##### `seba_control:api:statusSynced`
Indicates that `updateServerStatus` completed.

- **Payload:** `{ success: boolean, message: string }`

</Tab>
<Tab>

##### `seba_control:client:notification`
Broadcasts status messages when credit operations run.

- **Payload:** `{ type: 'success'|'error'|'info', message: string }`

##### `seba_control:client:balanceUpdated`
Sent when the server publishes a new balance to the player.

- **Payload:** `{ balance: number }`

##### `seba_control:client:bypassState`
Informs the client when bypass mode toggles.

- **Payload:** `{ enabled: boolean }`

```lua
AddEventHandler('seba_control:client:balanceUpdated', function(data)
    print(('Your new balance is: %s credits'):format(data.balance))
end)
```

</Tab>
</Tabs>

## Use cases

### 1. Shop system

```lua
local function buyItem(source, itemId, price)
    local success, message = exports.seba_control:spendCredits(source, price, "Store", "Purchase of " .. itemId)

    if success then
        givePlayerItem(source, itemId)
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[STORE]", "You bought " .. itemId .. " for " .. price .. " credits"}
        })
    else
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[ERROR]", message}
        })
    end
end

RegisterCommand("buy", function(source, args)
    if #args < 2 then
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[USAGE]", "/buy <item> <price>"}
        })
        return
    end

    local itemId = args[1]
    local price = tonumber(args[2])

    if not price or price <= 0 then
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[ERROR]", "Invalid price"}
        })
        return
    end

    buyItem(source, itemId, price)
end, false)
```

### 2. Daily reward system

```lua
local dailyRewards = {}

local function claimDailyReward(source)
    local discordId = exports.seba_control:seba_identifier(source, "discord")

    if not discordId then
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[ERROR]", "Unable to resolve your Discord ID"}
        })
        return
    end

    local today = os.date("%Y-%m-%d")

    if dailyRewards[discordId] == today then
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[REWARD]", "You already claimed today's reward"}
        })
        return
    end

    local rewardAmount = 100
    local success, message = exports.seba_control:addCredits(discordId, rewardAmount, "Reward System", "Daily reward")

    if success then
        dailyRewards[discordId] = today
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[REWARD]", "You received " .. rewardAmount .. " credits for today's reward"}
        })
    else
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[ERROR]", "Failed to grant reward: " .. message}
        })
    end
end

RegisterCommand("daily", function(source)
    claimDailyReward(source)
end, false)
```

### 3. Balance and transfer system

```lua
RegisterCommand("balance", function(source)
    local discordId = exports.seba_control:seba_identifier(source, "discord")

    if not discordId then
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[ERROR]", "Unable to resolve your Discord ID"}
        })
        return
    end

    local success, balance = exports.seba_control:getCachedBalance(discordId)

    if success then
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[BALANCE]", "Your current balance is: " .. balance .. " credits"}
        })
    else
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[ERROR]", "Unable to retrieve your balance: " .. balance}
        })
    end
end, false)

RegisterCommand("transfer", function(source, args)
    if #args < 2 then
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[USAGE]", "/transfer <player_id> <amount>"}
        })
        return
    end

    local targetId = tonumber(args[1])
    local amount = tonumber(args[2])

    if not targetId or not GetPlayerName(targetId) then
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[ERROR]", "Player not found"}
        })
        return
    end

    if not amount or amount <= 0 then
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[ERROR]", "Invalid amount"}
        })
        return
    end

    local success1, message1 = exports.seba_control:spendCredits(source, amount, "Transfer", "Transfer to player " .. targetId)

    if success1 then
        local targetDiscord = exports.seba_control:seba_identifier(targetId, "discord")
        if targetDiscord then
            local success2, message2 = exports.seba_control:addCredits(targetDiscord, amount, "Transfer", "Transfer from player " .. source)

            if success2 then
                TriggerClientEvent('chat:addMessage', source, {
                    args = {"[TRANSFER]", "You transferred " .. amount .. " credits"}
                })
                TriggerClientEvent('chat:addMessage', targetId, {
                    args = {"[TRANSFER]", "You received " .. amount .. " credits from " .. GetPlayerName(source)}
                })
            else
                TriggerClientEvent('chat:addMessage', source, {
                    args = {"[ERROR]", "Transfer failed, contact an administrator"}
                })
            end
        end
    else
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[ERROR]", message1}
        })
    end
end, false)
```

### 4. Administration system

```lua
RegisterCommand("addcredits", function(source, args)
    if not IsPlayerAceAllowed(source, "seba_control.admin") then
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[ERROR]", "Insufficient permissions"}
        })
        return
    end

    if #args < 2 then
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[USAGE]", "/addcredits <player_id> <amount>"}
        })
        return
    end

    local targetId = tonumber(args[1])
    local amount = tonumber(args[2])

    if not targetId or not GetPlayerName(targetId) then
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[ERROR]", "Player not found"}
        })
        return
    end

    local targetDiscord = exports.seba_control:seba_identifier(targetId, "discord")
    if not targetDiscord then
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[ERROR]", "Unable to resolve the player's Discord ID"}
        })
        return
    end

    local success, message = exports.seba_control:addCredits(targetDiscord, amount, "Administration", "Credits granted by admin " .. GetPlayerName(source))

    if success then
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[ADMIN]", "You granted " .. amount .. " credits to " .. GetPlayerName(targetId)}
        })
        TriggerClientEvent('chat:addMessage', targetId, {
            args = {"[ADMIN]", "You received " .. amount .. " credits from the administrator"}
        })

        exports.seba_control:invalidateBalanceCache(targetDiscord)
    else
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[ERROR]", message}
        })
    end
end, false)

RegisterCommand("serverstatus", function(source)
    if not IsPlayerAceAllowed(source, "seba_control.admin") then return end

    local success, message = exports.seba_control:updateServerStatus()

    TriggerClientEvent('chat:addMessage', source, {
        args = {"[STATUS]", success and "Status updated" or "Error: " .. message}
    })
end, false)
```

### 5. Casino / betting system

```lua
local function playSlots(source, bet)
    if bet < 10 or bet > 1000 then
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[CASINO]", "Bet must be between 10 and 1000 credits"}
        })
        return
    end

    local success, message = exports.seba_control:spendCredits(source, bet, "Casino", "Slots bet")

    if not success then
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[CASINO]", "Insufficient credits: " .. message}
        })
        return
    end

    local chance = math.random(1, 100)
    local winAmount = 0

    if chance <= 5 then
        winAmount = bet * 10
    elseif chance <= 20 then
        winAmount = bet * 3
    elseif chance <= 40 then
        winAmount = bet * 1.5
    end

    if winAmount > 0 then
        local discordId = exports.seba_control:seba_identifier(source, "discord")
        if discordId then
            exports.seba_control:addCredits(discordId, winAmount, "Casino", "Slots winnings")
            TriggerClientEvent('chat:addMessage', source, {
                args = {"[CASINO]", "You won " .. winAmount .. " credits!"}
            })
        end
    else
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[CASINO]", "You lost " .. bet .. " credits. Better luck next time!"}
        })
    end
end

RegisterCommand("slots", function(source, args)
    local bet = tonumber(args[1])
    if not bet then
        TriggerClientEvent('chat:addMessage', source, {
            args = {"[USAGE]", "/slots <amount>"}
        })
        return
    end

    playSlots(source, bet)
end, false)
```

## Backend endpoint structure

### Credits API (`/api/fivem`)
- `POST /spend`
- `POST /add`
- `GET /balance/:discordId`

### Servers API (`/api/servers`)
- `POST /server-status`
- `POST /refresh-card`
- `GET /server/:serverId`

### Health API
- `GET /health`

## Troubleshooting

1. **"Unable to resolve Discord ID"**
   - Confirm the player has Discord linked.
   - Double-check `sv_scriptHookAllowed` and the identifier permissions in `server.cfg`.
2. **"Authentication error"**
   - Ensure `FIVEM_SECRET` matches the value expected by the backend.
   - Verify the backend recognises the configured server ID.
3. **"API connection failed"**
   - Validate the configured URL and ensure the backend is reachable.
   - Confirm the backend service is running.
   - Temporarily enable bypass mode if you need to diagnose locally.
4. **"Transaction in progress"**
   - The transaction lock prevents duplicates; wait a few seconds and retry.

### Debug logging
- Enable bypass mode for more verbose output.
- Monitor the server console for HTTP request errors.

## License

This project is released under the MIT License. See `LICENSE` for details.